\chapter{Функционално програмиране}
\label{ch:functional-programming}

Функционалното програмиране е парадигма, която винаги е присъствала в програмния свят. Нейните основи се полагат още през 1930-та година чрез \emph{ламбда смятането}, развито от Алонсо Чърч. По-късно Чърч, заедно със своя ученик Алън Тюринг, разработват така наречения „Тезис на Чърч-Тюринг“ като доказват, че класовете изчислими функции по модела на ламбда смятането, по модела на общо-рекурсивните функци и тези, изчислими от машина на Тюринг, съвпадат. От там те излагат хипотезата че това са всички ефективно изчислими функции. Работата на Чърч и Тюринг ни позволява да говорим за тези модели като еквивалентни по изчислителна мощ.

Един от най-ранните функционални езици е Lisp, въведен през 1958-ма година от Джон Маккарти, последван от серия други, като ML през 1973-та. Преди 90-те години функционалните езици не добиват достатъчна популярност, но теорията около тях продължава да се развива, най-вече в академичните среди, резултат от което може да се види в езика Haskell от 1990-та. От 90-те и особено през последното десетилетие обаче се наблюдава значително подновен интересен към функционалното програмиране. Във все повече езици и програми се наблюдават функционални елементи, а функционалните езици добиват голяма популярност. Причината за това може да открием в нуждата от справяне с увеличаващата се комплексност на програмите, а в последните години и нуждата от модел, който да се вписва добре с особеностите на многоядрените и разпределените системи.

В тази глава ще разгледаме основните принципи на функционалното програмиране и средствата, които то предоставя за изграждане на абстракции.

\section{Какво е функционално програмиране?}

Най-общо може да дефиниране функционалното програмиране като парадигма, при която програмите се изграждат чрез прилагане на математически функции. За да вникнем по-добре в това е необходимо да разгледаме дефиницията на понятието \emph{функция}:

\begin{definition}
  Нека $X$ и $Y$ са множества, а $f \subseteq X \times Y$ е релация, такава че $\forall x \in X\, \exists! y \in Y$, такова че $(x, y) \in f$. Тогава $f$ наричаме \emph{функция} или \emph{тотална функция}.
\end{definition}

По-общо понятие е следното:

\begin{definition}
  Ако $\forall x \in X$ съществува най-много едно $y \in Y$, такова че $(x, y) \in f$, тогава $f$ наричаме \emph{частична функция}.
\end{definition}

Казано по друг начин, функция е изображение, което на всеки елемент от едно входно множество $X$ съпоставя като резултат елемент от друго множество $Y$, при това винаги един и същ. Ако $X$ е декартово произведение на няколко множества, тогава може да разглеждаме функцията като функция на няколко аргумента, всеки от съответното множество.

Може да забележим, че тази дефиниция е значително по-ограничена от познатите ни от императивното програмиране функции. Функциите при императивното програмиране могат да:

\begin{itemize*}
  \item хвърлят изключения, с което да прекъснат функцията, без тя да е върнала резултат;
  \item зависят от външни данни, които се променят. Това може да доведе до различен резултат;
  \item променят външно за функцията състояние, което може да бъде наблюдавано от други части на програмата;
  \item зависят от недетерминизъм, който да промени резултатът на функцията.
\end{itemize*}

Изброените свойства не са позволени за математическите функции, поради това че те винаги дават резултат и този резултат, за едни и същи входни аргументи, винаги е един и същ и определен само от тях. Единствените външни данни, от които те могат да зависят, са константи, и не могат да зависят от външни ефекти. Поради това те също така не могат да оказват влияние върху други функции в програмата. Изброените свойства може да обобщим като \emph{странични ефекти} и \emph{недетерминизъм}.

Така от дефиницията на \emph{функция} и от математическите ѝ основи можем да заключим, че един функционален език трябва да притежава следните характеристики:

\begin{itemize}
  \item \emph{Функциите в езика са първокласни обекти (стойности)} — по дефиницията по-горе математиката разглежда функциите като множество, което е релация с определени свойства, тоест като математически обекти (стойности). Това означава, че те могат да бъдат част от други математически обекти, като например множества, от което следва, че те също могат да бъдат аргументи на функции или да бъдат връщани като резултат от функция. Поради това един функционален език трябва да третира функциите като първокласни обекти в езика, тоест могат да бъдат реферирани (от например променливи) и могат да бъдат подавани на функции и връщани като резултат от функции.
  \item \emph{Поддържат се неизменияемост, неизминяеми структури от данни и ограничение на страничните ефекти} — по-горе разгледахме, че функциите на функционалното програмиране изключват тези неща. В математиката всички стойности са неизменяеми по природа. Когато в математиката говорим за изменяемо състояние то е на строго контролирани места, с ясно утвърдени правила, за да могат да бъдат формулирани математически твърдения.
  \item \emph{Наличие на мощна типова система} — в математиката всеки един разглеждан обект има ясна дефиниция или е определен от ясни свойства, които не могат да се променят. Също така всяко едно множество се състои от обекти с определени свойства, чрез които то е дефинирано. Тези множества могат да бъдат разглеждани като типове. От тяхното комбинирате по различен начин, например чрез логически операции, могат да бъдат получени нови множества с по-конкретни свойства. Това ни позволява да изказваме допълнителни твърдения и да прилагаме операции, за които сме сигурни, че са верни и смислени. Математическата основа позволява на функционалните езици да прилагат мощни типови системи, които ни дават всички тези ползи от математиката в програмирането. Чърч  развива своята теория за \emph{типизираното ламбда смятане}, която се явява основа на типизираните програмни езици.
\end{itemize}

В следващите секции ще разгледаме тези характеристики по-подробно.

За да се възползваме максимално от функционалното програмиране ни е необходим език, който силно поддържа тези характеристики. Поради това в тази дипломна работа ще използваме езика Scala.

\section{Функциите като първокласни обекти}

В Scala функциите, които са първокласни обекти, са инстанции на параметризираните типове Function1[-T, +R], Function2[-T1, -T2, +R], Function3[-T1, -T2, -T3, +R] и т.н., съответстващи на функции с един, два, три и т.н. аргумента. Означенията \code{-} и \code{+} определят съответно контравариантност и ковариантност по съответния тип. Това означава, че \code{FunctionN[B1, ..., BN, SR]} е подтип на \code{FunctionN[S1, ..., SN, BR]}, ако \code{Si} е подтип на \code{Bi} $\forall i = 1, \ldots, N$ и \code{SR} е подтип на \code{BR}:

\begin{lstlisting}
val fn: Function1[Int, Any] = (a: Any) => a.toString
\end{lstlisting}

Всеки от типовете има по-кратка нотация, съответно \code{T => R}, \code{(T1, T2) => R}, \code{(T1, T2, T3) => R} и т.н. Типовете дефинират абстрактен метод \code{apply} на $N$ аргумента, имащ съответните типове за аргументите и връщания резултат. При прилагането на оператора \code{()} този метод бива извикан автоматично:

\begin{lstlisting}
fn(2) == fn.apply(2)
\end{lstlisting}

Scala притежава литерал за лесно имплементиране на обекти от тези типове, тоест за лесно дефиниране на първокласни функции. Следващите примери го представят:

\begin{lstlisting}[texcl=true]
val double1 = (x: Int) => x * 2
val double2: Int => Int = x => x * 2
// \_ се замества с първия аргумент
val double3: Int => Int = _ * 2

def reduce3[T](a: T, b: T, c: T)(binOp: (A, A) => A) =
  binOp(binOp(a, b), c)

reduce3(1, 2, 3)((x: Int, y: Int) => x * y) // 6
reduce3(1, 2, 3)((x, y) => x * y) // 6
// Всеки \_ замества съответно първия и втория аргумент
reduce3(1, 2, 3)(_ * _) // 6
\end{lstlisting}

Обикновените (дефинирани чрез \code{def}) функции в Scala могат да бъдат преобразувани към първокласни обекти чрез \code{_}:

\begin{lstlisting}
def square(x: Int) = x * x
val squareFn: Int => Int = square _
\end{lstlisting}

Тук ще отбележим някои характерни свойства за обикновените функции в Scala:

\begin{itemize*}
  \item функциите могат да имат няколко списъка с параметри. Когато една функция на няколко параметъра се преобразува към функция с няколко списъка, всеки с точно един параметър, това се нарича кърироване (\englishterm{currying}, от името на математика Хаскел Къри). Математичеки това се изразява като комбинация от няколко междинни функции на един аргумент, всяка връщаща функция, с изключение на последната, която връща резултата.
  
  \item при извикване, ако даден параметър е част от единичен списък, то съответния му аргумент може да бъде подаден в къдрави скоби, вместо кръгли, като тези къдрави скоби имат семантиката на блок:
  
  \begin{lstlisting}
reduce3(1, 2, 3) { (a, b) =>
  a * b
}
  \end{lstlisting}
  
  \item методите могат да бъдат извиквани по един от тези синтаксиси:
  
  \begin{lstlisting}[texcl=true]
List(1, 2, 3).map(x => x * x)
List(1, 2, 3) map { x => x * x }
List(1, 2, 3) map squareFn
// тук обикновените функции автоматично се преобразуват към първокласни
List(1, 2, 3) map square
  \end{lstlisting}
\end{itemize*}

\subsection{Референтна прозрачност (\englishterm{referential transparency})}

Императивните програми се състоят основно от последователност от твърдения. Твърденията нямат резултат, вместо това тяхното действие се изразява в промяна на състояние. Наредбата и последователността на твърденията е изключително важна. Грешка в това може да се отрази на много места в програмата. Комбинирането на едно парче код с друго е трудно, защото трябва да се следят всички те.

Функционалните програми от своя страна се състоят от комбиниране на изрази. Всеки израз има единствено резултат, който може да бъде използван в друг израз, но няма странични ефекти. Във функционалните езици всички основни конструкции са изрази, включително \code{if} и \code{for}. Изрази са и блоковете, като те се оценяват до последния израз в себе си. Поради тези причини функционалното програмиране е декларативно програмиране.

\begin{lstlisting}[texcl=true]
// if и блоковете са изрази
def fact(n: Int) = {
  def factH(n: Int, acc: Int) = if (n == 0) acc else factH(n - 1, acc * n)
  factH(n, 1)
}
\end{lstlisting}

Характерно свойство за изразите е тяхната \emph{референтна прозрачност}. Това означава, че за всяка програма всяка една част от израз може да бъде заместена с нейната дефиниция или еквивалентен израз и програмата да не се промени \cite{chiusano2014FPinScala}. Ако за даден израз това не е изпълнено, то той има странични ефекти. Това ни позволява да прилагаме един от основните математически методи за доказателство — чрез заместване. Поради липсата на мутации можем да изследваме всяка една част от програмата локално и да прилагаме математически разсъждения и математически изводи за нея. Това е доста по-трудно да бъде направено за императивните езици, което води и до много грешки, особено при комбинация с конкурентни изчисления.

\begin{lstlisting}[texcl=true]
def sum(a: Int, b: Int) = a + b

// чрез постъпково прилагане на референтната прозрачност следните изрази са еквивалентни
reduce3(square(2), 3, 4 * 5)(sum)
sum(sum(square(2), 3), 4 * 5)
sum(sum(4, 3), 4 * 5)
sum(sum(4, 3), 20))
sum(4 + 3, 20)
sum(7, 20)
7 + 20
27
\end{lstlisting}

Понятието се пренася и върху функции, като една функция е референтно прозрачна, ако във всеки израз нейното извикване може да се замени с резултата ѝ.

\subsection{Композиране на фунции}

Едно от основните свойства, което притежават функциите, е композитност. Нека имаме $f: A \rightarrow B$ и $g: B \rightarrow C$. Тогава $h(x) = g(f(x))$ е функция, композиция на $f$ и $g$. Това означаваме като $h = f \cdot g$.

Композицията има следните свойства:

\begin{itemize*}
 \item \emph{асоциативност} — нека $f: A \rightarrow B$, $g: B \rightarrow C$ и $h: C \rightarrow D$. Тогава $(f \cdot g) \cdot h \cong f \cdot (g \cdot h)$;
 \item \emph{наличие на единичен елемент} — нека $id(x) = x$. Тогава $\forall f$ $id \cdot f = f \cdot id = f$. $id$ е единичният елемент.
\end{itemize*}

При функциите на няколко аргумента може да разглеждаме тяхната композитност при горната дефиниция като ги кърироваме.

Композитността е доста силно свойство, поради това че ни позволява да изграждаме функции от комбинирането на други по-малки такива. Както ще видим в следващата секция, това дава възможност за създаване на преизползваеми абстракции.

\subsection{Функции от по-висок ред и създаване на абстракции}

Много операции на императивни езици имат следния вид:

\begin{lstlisting}[language=Java]
public List<B> someOperation(List<A> input) {
    List<B> result = new ArrayList<>();

    for (item : input) {
        if (<some predicate on item>) {
          result.add(<some transformation on item>);
        }
    }
    
    return result;
}
\end{lstlisting}

Често кодът съдържа и допълнителни изчисления, но се различава основно във конкретните трансформации и предикати. Въпреки че той конструктивно е идентичен, кодът обикновено се изписва в този си пълен вид във всяка такава операция. Причината за това е, че обикновено императивните езици нямат удобни способи за композиране на по-малки операции и извеждане на абстракции, тъй като те се базирани на постъпкови промени, вместо на трансформация на данни. Това често налага и използването на изменяеми структури, което при по-сложна логика би направило това разделяне на части по-трудно. Тези повтарящи се конструкции представляват \emph{инцидентна} сложност — код, който не описва директно самата задача, а описва детайли за как тя да бъде решена \cite{brroks1987NoSilverBullet}.

Функционалното програмиране се опитва да намали инцидентната сложност до минимум и успява да го направи благодарение на композитността. Нека да отделим от горния код две операции:

\begin{itemize*}
  \item \code{def map[A, B](xs: List[A])(f: A => B): List[B]} — прилага операцията \code{f} върху всеки елемент на \code{xs} и връща списък от съответните резултати;
  \item \code{def filter[A](xs: List[A])(f: A => Boolean): List[A]} — прилага предиката \code{f} и връща списък от онези елементи на xs, за които той е бил в сила.
\end{itemize*}

Тяхната имплементация е инцидентна сложност, важна е семантиката им. Нека да решим проблема чрез тях:

\begin{lstlisting}
def someOperation[A](xs: List[A]) =
  map(filter(xs)(<some predicate>))(<some transformation>)
\end{lstlisting}

Така композирахме функциите \code{map}, \code{filter} и две други функции, които са част от проблема, и получихме решение, което точно описва задачата, с минимални детайли относно имплементацията. Получихме чисто решение, а детайлите като оптимизация са скрити в съответните функции.

Функционалното програмиране ни позволява да изграждаме много такива малки функции, които решават точно конкретен проблем, и които да композираме в ясен код, без излишни детайли. Те ни носят сигурност, че ще получим правилен резултат, без да е нужно да проследяваме постъпково изпълнението на нашия код и мутираните от него данни. Много от тези функции приемат като аргументи други първокласни функции, които съдържат част от логиката на задачата. Функции, които приемат други функции или връщат функции, се наричат \emph{функции от по-висок ред}. Колекциите на Scala съдържат много такива дребни абстракции.

\begin{lstlisting}[texcl=true]
// сумата на 100-те най-добри резултата на пълнолетните състезатели 
competitors.filter(_.age >= 18).map(_.score).sortBy(-_).take(100).sum
\end{lstlisting}

Самата имплементация избира как да оптимизира изпълнението. Тя може да реши да не изпълнява функциите веднага, а да ги комбинира оптимално и да извърши изчисление едва когато резултатът е необходим (мързеливо (\englishterm{lazy}) оценяване). От друга страна, благодарение на асоциативността на композирането и на операциите, може всички изчисления да се изпълнят паралелно. В Scala колекциите позволяват превключване към първата имплементации чрез метода \code{view}, а към втората чрез \code{par}.

\section{Неизменяемост и ограничение на страничните ефекти}
\label{sec:immutability}

В предишната секция видяхме, че липсата на странични ефекти има големи ползи при композирането на функции и изрази. В предишната глава видяхме проблемите, които се срещат при използване на синхронизационни конструкции и изменяеми споделени данни в конкурентна среда. Направихме извода, че изменяемостта е основния източник на комплексност за програмите.

Императивните програми се основават на постъпкови промени във времето \cite{odersky2013ObjectsAndFunctions}. Времето е интегрална част от тях тъй като всяко едно състояние може да е различно, в зависимост от това в кой момент го изследваме. Всяка стъпка зависи от реда на всички предишни, поради което е трудно те да бъдат проследени и да бъдат изказвани твърдения за тях. Когато добавим паралелизъм тогава всяка една нишка на всяка една изчислителна система има собствена времева линия. Споделяне на състояние между тях води до недетерминизъм — физически е невъзможно да се получи консистентност. За спряване с недетерминизма е необходимо синхронизация на времевите линии, което води до по-голяма комплексност, възможност за грешки или мъртва хватка (\englishterm{deadlock}), изключително трудно валидиране на програмата във всички случаи, намалена производителност поради невъзможността двете времеви линии да се развиват парарелно, а от там и до намалена скалируемост. Затова разпределените системи не се вписват с изменяемото състояние.

Функционалното програмиране предоставя друг подход. При него всяка една стойност е моментна снимка на реалността \cite{odersky2013ObjectsAndFunctions}\cite[глава 3]{bernhardt2015ReactiveWeb}. Функционалното програмиране предоставя конструкции за трансформация на тези стойности. Времето липса като фактор, поради което всяка една последователност от изчисления ще даде един и същи резултат. Това от една страна спомага данните да бъдат свободно споделяни между парарелни процеси, а от друга самите изчисления да бъдат извършени паралелно, без промяна на резултата. Програмите могат да бъдат проследени и валидирани сравнително лесно. Затова функционалното програмиране и неизменяемите стойности изключително много подпомагат разпределеното програмиране и неговата скалируемост.

Съществуват множество имплементации на неизменяеми структури. Голяма част от тях са изследвани в работата на Крис Окасаки \cite{okasakiFunctionalDS}. Те са оптимални по производителност и предоставят свойството \emph{персистентност}. То се изразява в това, че новите версии на една структура преизползват максимално паметта на старата, което позволява съществуването на всички версии, без те да заемат огромно количество памет. Това е възможно благодарение на неизменяемостта. Тези имплементации позволяват неизменяемите структури да бъдат с оптималност, сравнива с тази на изменяемите, и така използването им не се отразява негативно, а споделянето на няколко версии на една структура е дори по-ефективно. Scala използва неизменяеми структури по подразбиране.

Програмите обаче трябва да могат да взаимодействат с външния свят. Разпределените програми трябва да могат да изпращат съобщения помежду си. Всъщност всяка една програма има странични ефекти — изменяне на паметта на машината, натоварване на неговия процесор и други. Да вземем за пример операцията за сравнение на обекти по референция. Тя е операция, която ни позволява да сравняваме разположението на обекти в паметта, което води до нарушаване на референтната прозрачност \cite{chiusano2014FPinScala}:

\begin{lstlisting}[texcl=true]
val xs = List(1, 2, 3)

xs eq xs // true

// Нека да заместип xs в горния израз:
List(1, 2, 3) eq List(1, 2, 3) // false — референтната прозрачност е нарушена

// Операцията == от своя стране е референтно прозрачна
xs == xs // true
List(1, 2, 3) == List(1, 2, 3) // true
\end{lstlisting}

Затова когато говорим за странични ефекти във функционалните програми ще разглеждаме само тези от тях, които можем да наблюдаваме от нашия код, тъй като само те могат да му влияят. Ще ограничим наблюдаваните странични ефекти до специални места в нашите програми:

\begin{itemize*}
  \item преди входа и след изхода на/от функционални трансформации, възможно най-външно в нашите програми;
  \item скрити зад специални абстракции или функции. В \labeledref{секция}{sec:monads} ще разгледаме абстракция, наречена монада, която ни позволява да скриваме страничните ефекти зад типове, които ще наричаме ефекти;
  \item в някои случаи ще позволим само ограничен набор от проследими странични ефекти. Ще видим този подход в следащата глава когато говорим за актьори. Други примери са \englishterm{Software Transasction Memory} (популяризирано от езика Clojure) или използването на дневници при програмите, което ни позволява да ги наблюдаваме, без това да променя тяхното действие.
\end{itemize*}

Ще отбележим, че за да бъде една функция референтно прозрачна, то не е задължително тя да няма странични ефекти, стига те да са изолирани от външния свят, което значи функцията да остава функция в математическия смисъл. Така в някои случаи може да прилагаме оптимизации, свързани със изменяемо състояние, които да остават незабелязани.

\section{Типова система}

Развитата типова система е нещо много характерно за функционалното програмиране. Мартин Одерски, авторът на Scala, класифицира типовите системи по следните категории \cite{odersky2013Types}:

\begin{itemize*}
  \item \emph{силно (строго) и слабо типизирани системи} — стойностите (обектите) в силно типизираните езици имат точно определен тип и опитът те да бъдат третирани като други, логически несъвместими типове, води до грешка. При слабо типизираните системи това е позволено;
  \item \emph{статично и динамично типизирани системи} — при статично типизираните езици типът на изразите и променливите е известен и може да бъде верифициран, което става най-често по време на компилация. При динамичните езици тези проверки липсват, като грешките се откриват по време на изпълнение.
  \item Одерски разграничава статичните системи допълнително като \emph{детайлни и груби} — детайлните езици предоставят разширени конструкции за комбиниране и специфициране на типове и техни характеристики, които също биват проверявани статично. Грубите езици са бедни на такива конструкции.
\end{itemize*}

Типичен пример за слабо типизираните езици са асемблерните езици или езикът C. Някои езици като JavaScript и PHP също се доближават до слабата типизация с някои техни конструкции. Всички популярни функционални езици, включително езиците от семейството на Lisp, са строго типизирани. Не всички обаче имат другите характеристики.

Езикът ML е първият статично типизиран функционален език. Популярни статични езици, които са силно типизирани, но груби, са например Java преди версия 5 и Go. Java преди версия 5 не позволява комбинирането на типове, поради което програмирането често е по-трудно. Налага се използването на общи типове като \type{Object} и постоянно преобразуване до конкретни типове, което обаче няма как да бъде валидирано от статичната система и поради това често води до грешки. Благодарение на строгата типизация на Java тези грешки се улавят по време на изпълнение. Java версия 5 въвежда конструкции за \englishterm{generics}, което позволява неща като параметризирани типове, ограничена поддръжка на вариантност на параметризирани типове (при мястото на използване на типа), базисна поддръжка на екзистенциални типове и други, като те биват валидирани статично, още по време на компилация. Това прави езика по-богат, но не толкова, колкото някои други езици. Езикът C\# е съизмерим с Java.

Интересни са статичните езици, които са детайлни и строго типизирани. Най-често това са функционални езици. Такива са например Haskell, Scala, F\# и OCaml. Те се характеризират с по-детайлни структури за комбиниране на типове, често базирани на логиката \cite{odersky2013Types}. Scala допълва разгледаните в Java с например сечение на типове, типове от по-висок род, рефиниране на типове. Scala поддържа също така вариантност (ковариантност и контравариантност както при декларация на параметризиран тип, така и при използване на такъв), структурно подтипизиране, \englishterm{implicits} и класове на типове и други. Ще видим някои от тях в следващите секции.

Силно характерно за детайлно и строго типизирани езици е и така нареченото дедуциране на типове (\englishterm{type inference}). То позволява типовете на някои изрази и стойности да бъдат подразбрани автоматично без да е необходимо те да бъдат декларирани. Това изключително много подпомага програмирането на статични езици, тъй като тези декларации често са източник на комплексност. Във функционалните езици най-често за това се използва типовата системата на Хиндли-Милнер \cite{hindley1969, milner1978}. Благодарение на нея в езици като Haskell на много малко места е необходимо да бъдат поставяни типови декларации. Във функционални езици, поддържащи подтипизиране, като например Scala, тя обаче не е приложима. Scala използва друга система за дедуциране на типове, при която най-често се налага деклариране на типове единствено при описание на аргументите на функции.

Мощната типова система на тези езици улеснява програмирането и с това, че цял клас от грешки няма как да се случат, поради това че компилаторът ги проверява за нас. Това доставя увереност на програмиста и улеснява тестването, поради това че не е необходимо писането на тестване за проверка на типовете. Детайлната система позволява и интересни неща, като \englishterm{implicits} в Scala и контекстни класове на типове, които ще видим в \shortlabeledref{секция}{sec:typeclasses}.

\section{Опционалност}
\label{sec:optionallity}

Една от най-често срещаните грешки в компютърните програми е работата с неочаквани \lstinline{null} стойности, проявяващи се в езика Java като \type{NullPointerException}. Тони Хор, който въвежда \lstinline{null} стойностите в програмните езици, дори нарича това своята „грешка за милиард долара“ \cite{hoare2009Null}.

Същевременно в математиката не съществува специална стойност, която може да бъде приемана или връщана от всички функции. Когато е възможна липса на стойност, то самите функции, вместо върху оригиналното множество $X$, се дефинират върху специално разширено множество, например $X_{\perp} = X \cup \{\perp\}$, където $\perp \notin X$. Тогава възможността за опционалност се изразява чрез стойността $\perp$ и става явна, а при работа с нея тя се разглежда като задължителен случай.

Нека да направим същото нещо и във функционалното програмиране. Нека да създаден тип \type{Option[T]} с два подтипа — \type{Some[T]}, изразяваш наличие на стойност от тип \type{T} и \type{None}, изразяваш липса на стойност:

\begin{lstlisting}
sealed trait Option[+T] {
  def get: T
  def isEmpty: Boolean
}
case class Some[+T](value: T) extends Option[T] {
  def get = value
  def isEmpty = false
}
case object None extends Option[Nothing] {
  def get = throw new NoSuchElementException()
  def isEmpty = true
}
\end{lstlisting}

Ключовата дума \lstinline|sealed| ограничава възможните подтипове на \type{Option} до разглежданите два. Обектите от тип \type{Some} са неизменяеми, което ни позволява да декларираме параметъра му \type{T} като ковариантен, благодарение на което \type{Some[S]} е подтип на \type{Some[B]}, ако \type{S} е подтип на \type{B}. Това съответства на възможността обект от подтип да бъде разглеждат като обект от базов тип при липса на опционалност. Ковариантността и наличието в Scala на тип \type{Nothing}, който е подтип на всеки друг тип в езика, ни позволява да изразим \type{None} като \englishterm{singleton} обект, вместо да е необходимо да имаме \type{None} обект за всеки един тип, както би било в езици с по-бедна типова система. Така \type{None} е подтип на \type{Option[T]} за всяко \type{T}, което съответва на \lstinline{null} в езици със \lstinline{null} стойности:

\begin{lstlisting}
def increment(value: Option[Int]) =
  if (!value.isEmpty) Some(value.get + 1) else None

increment(Some(5)) // Some(6)
increment(None) // None
\end{lstlisting}

Стандартната библиотека на Scala реализира опционалните типове точно по същия начин.

Това, което постигнахме, е, че направихме опционалността явен ефект в нашите програми, когато тя е налична. Това ни предпазва от възможността да я пропуснем, което би довело до грешка. Но кодът, който използва така реализирания \type{Option} тип, не изглежда по-добър от стандартен код при \lstinline{null} стойности — необходимо е разглеждане на всеки един случай (наличие или липса на стойност), като случаите нарастват експонентциално с нарастване на броя на опционалните стойности. Нека да се възползваме от възможността за изграждане на абстракции чрез функционалното програмиране и дефинираме следните методи към типа \type{Option}:

\begin{lstlisting}
sealed trait Option[+T] {
  def get: T
  def isEmpty: Boolean
  
  def getOrElse[V >: T](default: => V): V =
    if (isEmpty) default else get
  def orElse[V >: T](default: => Option[V]): Option[V] =
    if (isEmpty) default else this
  def map[V](f: T => V): Option[V] =
    if (isEmpty) None else Some(f(get))
  def filter(f: T => Boolean): Option[T] =
    if (isEmpty || !f(get)) None else this
}
\end{lstlisting}

Така дефинирахме различни преизползваеми абстракции за различни случаи на използване на опционалността, което би опростило техния код и ни предпазва от опасния метод \lstinline|get| (който при невнимание би хвърлил изключение):

\begin{itemize*}
  \item \lstinline{getOrElse} — извличане на стойността или използване на стойност по подразбиране при нейната липса. Стойността по подразбиране се подава по име, което позволява тя да не бъде изчислявана, освен ако не е необходимо
  \begin{lstlisting}
val numberOfThreads: Int = threadPoolConfig.numberOfThreads getOrElse DefaultNumberOfThreads
  \end{lstlisting}
  
  \item \lstinline{orElse} — използване на алтернативен източник при липса на стойност. Той се подава по име
  \begin{lstlisting}
def getConfigValue(value: String): Option[String] =
  localConfig.get(value) orElse userConfig.get(value) orElse systemConfig.get(value)
  \end{lstlisting}
  
  \item \lstinline{map} — трансформиране на стойност, ако тя е налична
  \begin{lstlisting}
def increment(value: Option[Int]) = value map { _ + 1 }
  \end{lstlisting}
  
  \item \lstinline|filter| — филтриране на стойността
  \begin{lstlisting}
people.findById(id) filter { _.age >= 18 } map { _.name }
  \end{lstlisting}
\end{itemize*}

Горните абстракции не ни позволяват да решим един друг често срещан и важен случай. Нека имаме три функции:

\begin{lstlisting}
def f(n: Int): Int = ???
def g(n: Int): Int = ???
def h(n: Int): Int = ???
\end{lstlisting}

Поради съвпадение на типа на резултата и на аргумента те могат да бъдат композирани — \lstinline|h(g(f(n)))|. Ако функциите генерират опционалност те биха имали следния вид:

\begin{lstlisting}
def f(n: Int): Option[Int] = ???
def g(n: Int): Option[Int] = ???
def h(n: Int): Option[Int] = ???
\end{lstlisting}

Тук обаче вече липса съвпадение на типа, което не ни позволява да композираме функциите (\lstinline|h(g(f(n)))| вече е грешно), с което загубихме едно от най-важните свойства, което представихме за функциите — композитност. Много грешки в езици с \type{null} всъщност идват от неочаквана \type{null} стойност при такава композиция. Тук ние избягваме това, но губим и композицията, което води до следния код:

\begin{lstlisting}
def composedFGH(value: Int): Option[Int] = {
  val fOption = f(value)
  if (fOption != None) {
    val gOption = g(fOption.get)
    if (gOption != None) h(gOption.get)
    else None
  } else {
    None
  }
}
\end{lstlisting}

За да решим този проблем ще приложим стандартния подход във функционалното програмиране — въвеждане на абстракция. Тази абстракция ще разгледаме във \labeledref{секция}{sec:monads}.

\section{Работа с грешки и изключения}

Както видяхме в началото на главата, хвърлянето на изключение е страничен ефект, което може да илюстрираме по-добре в следния пример:

\begin{lstlisting}
def exceptionThrowing(n: Int): Int = {
  val m: Int = throw new Exception()
  
  try {
    n + m
  } catch {
    case _: Throwable => 0
  }
}
\end{lstlisting}

Референтната прозрачност ни позволява в израза \lstinline|n + m| да заместим \lstinline|m| с неговата дефиниция без промяна на поведението:

\begin{lstlisting}
def exceptionThrowing(n: Int): Int = {
  try {
    n + throw new Exception()
  } catch {
    case _: Throwable => 0
  }
}
\end{lstlisting}

Двата кода обаче се държат различно — първият винаги хвърля изключение, а вторият връща 0. Това означава, че референтната прозрачност всъщност е нарушена поради странични ефекти.

Допълнително при асинхронно и разпределено програмиране няма как да се възползваме от изключенията, поради това че те са обвързани със стека на текущата нишка. Нужен ни е подходящ формат.

Нека да дефинираме функционални абстракции за работа с грешки.

\subsection{Тип за изключения \type{Try}}

Нека да опитаме да направим нещо аналогично на \type{Option}. Всъщност дори бихме могли да използваме опционалността и \type{None} за сигнализиране на грешка, но \type{None} не ни позволява да предадем каква е била тя. Стандартните изключения в Scala (и Java) са много добри за описване на грешки и изключителни ситуации и затова нека да създадем тип \type{Try[+T]}, базиран върху тях, с два подтипа:

\begin{itemize*}
  \item \type{Success[+T](value: T)}, изразяващ успех и наличие на стойност, подобно на \type{Some[T]};
  \item \type{Failure[+T](exception: Throwable)}, изразяващ грешка и съхраняващ причината за грешката под формата на изключение. Това е аналогично на \type{None}, с тази разлика, че съхраняваме допълнителна информация, поради което не можем да се възползваме от \englishterm{singleton} обект.
\end{itemize*}

Към класовете бихме могли да дефинираме и аналогични на \type{Option} функции за трансформации, включително и такива, трансформиращи \type{Failure} стойностите (методи \code{recover} и \code{recoverWith}). Реализацията е аналогична и може да бъде видяна в \shortlabeledref{приложение}{att:fp}. В стандартната библиотека на Scala е реализиран Try по аналогичен начин.

Така получихме възможността да изразяваме изключения без странични ефекти:

\begin{lstlisting}
def exceptionThrowing1(n: Int): Try[Int] = {
  val m: Try[Int] = Failure[Int](new Exception())

  m map { n + _ } recover {
    case _: Throwable => 0
  }
}

def exceptionThrowing2(n: Int): Try[Int] = {
  Failure[Int](new Exception()) map { n + _ } recover {
    case _: Throwable => 0
  }
}

exceptionThrowing1(2) // Success(0)
exceptionThrowing2(2) // Success(0)
\end{lstlisting}

Обектите от тип \type{Try} могат също така свободно да бъдат предавани между различни нишки или разпределено по мрежата като съобщения.

Подобно на \type{Option}, тази реализация има същия проблем с композирането на функции, боравещи върху \type{Try} обекти, който ще решим в \labeledref{секция}{sec:monads}.

\subsection{Сумарни типове \type{Either} и \type{Validation}}
\label{sec:sum-types-either-validation}

Понякога изключенията не са подходящ тип за боравене с грешки. В тези случаи се налага грешките да бъдат представени чрез обекти с по-специфична информация. За да постигнем това може да генерализираме \type{Try} чрез по общ-тип \type{Either[+E, +T]}, където \type{E} е типът на грешките, а \type{T} е типът на стойностите. Реализацията би била аналогична на \type{Try}, заедно с разгледаните трансформиращи функции (\shortlabeledref{приложение}{att:fp}).

Стандартната библиотека на Scala съдържа тип \type{Either[+L, +R]}, но той е по-общ с това, че може да се използва не само за работа с грешки, но и като тип, сумиращ два типа \type{L} и \type{R}, тоест обектите от тип \type{Either} обвиват или обект от тип \type{L} или \type{R}. Поради това той не поддържа директно трансформиращите функции. По конвенция когато се използва за грешки \type{L} е типът за грешни стойности, а \type{R} типът за успешни.

Понякога искаме да изпълним няколко операции едновременно и да комбинираме резултатите от тях. Би било удобно всички грешки, генерирани от тях, да се комбинират в списък от грешки. Пример за това е валидирането на няколко полета от уеб формуляр. Валидацията на различни полета протича независимо и накрая бихме искали да върнем всички грешки на клиента, ако има такива. За ще може да създадем тип \type{Validation[E, T]}, подобен на \type{Either}, който вместо единична грешка поддържа множество от грешки:

\begin{lstlisting}
sealed trait Validation[+E, +T]
case class Valid[+E, +T](value: T) extends Validation[E, T]
case class Invalid[+E, +T](errors: NonEmptyList[E]) extends Validation[E, T]
\end{lstlisting}

Пример за използването му ще видим в \labeledref{секция}{sec:applicatives}.

\section{Класове на типове}
\label{sec:typeclasses}

Много математически абстракции е трудно да бъдат представени чрез ООП конструкциите, които ни предоставят повечето езици. За пример нека разгледаме понятието \emph{моноид}

\begin{definition}
  Нека $M$ е непразно множество с бинарна операция „$\cdot$“. $M$ ще наричаме \emph{моноид}, ако:
  
  \begin{itemize*}
    \item \emph{операцията е асоциативна}, тоест $\forall a, b, c \in M$ е изпълнено $(a \cdot b) \cdot c = a \cdot (b \cdot c)$;
    \item \emph{съществува единичен елемент} $e \in M$, такъв че $\forall a \in M$ е изпълнено $e \cdot a = a \cdot e = a$
  \end{itemize*}
\end{definition}

(Ако към тези изисквания се добави и условие за наличие на обратен елемент, тогава моноида ще бъде група.)

Необходими са ни две неща за да реализираме тази абстракция:

\begin{itemize*}
  \item начин за специфициране на операция за всеки обект от даден тип върху обекти от този тип. В ООП това става чрез параметризиран абстрактен базов тип;
  \item начин за специфициране на операция към всеки тип. Това е операцията, която ни дава единичния елемент на моноида. В ООП липсва директен начин за постигане на това. 
\end{itemize*}

Абстрактните базови класове в ООП дефинират множество от обекти, с определени свойства. Това, което искаме да реализираме всъщност, е цял клас от типове с определени свойства, което повечето ООП езици не ни предоставят.

За да решим това ще изградим абстракция чрез типовата система на функционалните езици. Конструкцията, по която ще направим това, ще наречем \emph{класове на типове} (\englishterm{typeclasses}). Класовете на типове са въведени за първи път в езика Haskell. Тук ще разгледаме реализация на езика Scala \cite{oliveira2010TypeClasses}.

Нека отделим реализацията на двете операции на моноидите отделно от техния тип. Така получаваме следния тип:

\begin{lstlisting}
trait Monoid[T] {
  def op(a: T, b: T): T
  def identity: T
}
\end{lstlisting}

За да разглеждаме един тип като инстанция от класа \type{Monoid} трябва да предоставим обект, който имплементира моноидните операции. Нека да дефиниране имплементацията за моноида на целите числа относно операцията събиране:

\begin{lstlisting}
val intAdditiveMonoid = new Monoid[Int] {
  def op(a: Int, b: Int): Int = a + b
  def identity: Int = 0
}
\end{lstlisting}

Друг пример е моноида на низовете относно операцията конкатениране:

\begin{lstlisting}
val stringMonoid = new Monoid[String] {
  def op(a: String, b: String): String = a + b
  def identity: String = ""
}
\end{lstlisting}

Сега вече можем да дефинираме операции, които важат за всички моноиди. Такава е например операцията \code{sum}, която извършва операцията за всички елементи от подаден списък:

\begin{lstlisting}
def sum[T](xs: List[T])(m: Monoid[T]) = {
  xs.foldLeft(m.identity)((acc, next) => m.op(acc, next))
}

sum(List(5, 6, 7, 8, 9))(intAdditiveMonoid) // 35
sum(List("Hello", " ", "World", "!!!"))(stringMonoid) // "Hello World!!!"
\end{lstlisting}

Дотук използвахме единствено конструкции, които можем да изразим във всеки друг ООП език. Успешно реализирахме абстракция за класа на моноидните типове, но все още липсва полиморфизмът, който бихме очаквали от нея. Конкретните имплементации трябва да се подават ръчно, което отслабва ползата от абстракцията.

В математиката много неща се определят от контекста. Например ако разглеждаме целите числа, те могат да бъдат моноиди както по операцията събиране, така и по операцията умножение. Контекстът, в който те се разглеждат (определен например в началото или подразбиращ се по някакъв начин), характеризира за коя операция става въпрос. Scala притежава механизъм за определяне на контекст, който се възползва от детайлната статична типизация на езика. Това става чрез така наречените \emph{имплицитни стойности и параметри}.

В Scala параметрите от последния списък с параметри на една функция могат да бъдат декларирани като имплицитни. Ако при извикване на функцията бъдат пропуснати аргументите от последния списък, то компилатора се опитва да ги открие автоматично. За целта търси стойности и функции, декларирани като имплицитни и имащи съвпадащ тип, подред в следните области:

\begin{enumerate*}
  \item текущата област на видимост (дефинирани в нея или включени (\englishterm{import}) от друго място);
  \item съпътстващите обекти на някой от типовете, асоциирани с типа на параметъра.
\end{enumerate*}

Нека да приложим това за нашите моноидни имплементации и функцията \code{sum}:

\begin{lstlisting}[texcl=true]
package monoids

// ...

package object monoids {
  implicit val intAdditiveMonoid = new Monoid[Int] {
    def op(a: Int, b: Int): Int = a + b
    def identity: Int = 0
  }
  
  implicit val intMultiplicativeMonoid = new Monoid[Int] {
    def op(a: Int, b: Int): Int = a * b
    def identity: Int = 1
  }
  
  implicit val stringMonoid = new Monoid[String] {
    def op(a: String, b: String): String = a + b
    def identity: String = ""
  }
}

// ---------------
// в друг файл

import monoids.intAdditiveMonoid
import monoids.stringMonoid

def sum[T](xs: List[T])(implicit m: Monoid[T]) = {
  xs.foldLeft(m.identity)((acc, next) => m.op(acc, next))
}

sum(List(5, 6, 7, 8, 9)) // 35
sum(List("Hello", " ", "World", "!!!")) // "Hello World!!!
sum(List(5, 6, 7, 8, 9))(intAdditiveMonoid) // Все още можем явно да подадем имплементацията
\end{lstlisting}

Реализацията ни позволява да сменим контекста, когато желаем:

\begin{lstlisting}
{
  import monoids.intMultiplicativeMonoid
  
  sum(List(5, 6, 7, 8, 9)) // 15120
}
\end{lstlisting}

В съпътстващия обект на \type{Monoid} можем да дефинираме имплементации по подразбиране за някои вградени типове. Това може да направим и в съпътстващите обекти на типовете, които ние създаваме.

\begin{lstlisting}
trait Monoid[T] { ... }

object Monoid {
  implicit val intAdditiveMonoid = new Monoid[Int] { ,,, }
}

// ...

sum(List(5, 6, 7, 8, 9)) // 35

{
  import monoids.intMultiplicativeMonoid
  
  sum(List(5, 6, 7, 8, 9) // 15120
}
\end{lstlisting}

Полиморфизмът, който постигнахме, се нарича \englishterm{ad-hoc} полиморфизъм. Имплементацията на езика Scala ни дава следните ползи:

\begin{itemize*}
  \item разделяне (\englishterm{decoupling}) на имплементацията на класа за типа от самия тип;
  \item това ни дава възможност да разглеждаме вече съществуващи типове като инстанции на различни класове;
  \item възможност за дефиниране на операции не само върху определен тип обекти, но и върху обекти от цял клас от типове. Това значително увеличава преизползваемостта и ни позволява да третираме различни типове по един и същи начин, когато те имат общи свойства;
  \item автоматичен контекстно-ориентиран полиморфизъм;
  \item възможност за дефиниране на повече от една имплементация, която да бъде избирана в зависимост от контекста.
\end{itemize*}

Съществуват най-различни добре познати класове на типове \cite{yorget2009Typeclasses}. Допълнително можем да ги използваме за наши собствени абстракции. В следващите секции ще разгледаме някои популярни класове.

\section{Монади и композиране на ефекти}
\label{sec:monads}

\emph{Ефект} ще наричаме всеки параметризиран тип, който обвива някакво множество от стойности около определено свойство.

В предишните секции видяхме как приложението на различни ефекти, като опционалност, \type{Try} и други, води до загуба на композитността. Нека да опитаме да решим този проблем.

Да разгледаме конкретен ефект \type{F}. Това, което искаме да получим, е операция \code{compose}:

\begin{lstlisting}
def compose[A, B, C](f: A => F[B], g: B => F[C]): A => F[C]
\end{lstlisting}

Операцията трябва да има свойствата на нормалната композитност на функции:

\begin{itemize*}
  \item \emph{асоциативност} — нека $f: A \rightarrow F[B], g: B \rightarrow F[C], h: C \rightarrow F[D]$. Тогава $compose((compose(f, g), h)) \cong compose(f, compose(g, h))$;
  \item \emph{наличие на единичен елемент} $unit: U => F[U]$, дефиниран върху всяко множество $U$, такъв че $\forall f: A => F[B]$ е изпълнено $compose(unit, f) \cong compose(f, unit) \cong f$. $unit$ съответства на идентитета при нормалната композиция.
\end{itemize*}

Типовете, които притежават тези свойства, ще наричаме \emph{монади}. Нека да дефенираме клас за тях:

\begin{lstlisting}
trait Monad[F[_]] {
  def compose[A, B, C](f: A => F[B], g: B => F[C]): A => F[C]
  def unit[A](a: => A): F[A]
}
\end{lstlisting}

Типът \type{F[_]} е тип от по-висок (втори) род. Той представя параметризиран тип с произволен параметър. Тази конструкция липсва в повечето езици, като например Java, поради което абстракцията монада не може да бъде реализирана по този начин чрез тях. Операцията \code{unit} приема аргумента си по име, за да се даде възможност на монадата да реши как да го изчисли (ще видим приложение на това когато разглеждаме \type{Future} монади).

Монадите и моноидите са абстракции от теория на категориите. Може да забележим, че те са с доста общи свойства помежду си — и двете се определят от асоциативна бинарна операция и единичен елемент, но монадите са дефинирани върху специални функции, наричани \emph{стрелки на Клейсли}, а моноидите върху множества. Теория на категориите разглежда монадите и моноиди като свързани понятия.

Нека да имплементираме типа \type{Option} като монад:

\begin{lstlisting}
implicit val optionMonad = new Monad[Option] {
  def compose[A, B, C](f: A => Option[B], g: B => Option[C]): A => Option[C] =
    a => f(a) map { b => g(b) } getOrElse None
  def unit[A](a: => A): Option[A] = Some(a)
}
\end{lstlisting}

Сега вече можем да изразяваме композитност. Нека да приложим \code{compose} към последния пример от \shortlabeledref{секция}{sec:optionallity}:

\begin{lstlisting}
def composedFGH(value: Int)(implicit m: Monad[Option]): Option[Int] = {
  m.compose(m.compose(f, g), h)(value)
}
\end{lstlisting}

Често вместо операцията \code{compose} за основна се разглежда операцията \code{flatMap} със следната сигнатура:

\begin{lstlisting}
def flatMap[A, B](m: F[A])(f: A => F[B]): F[B]
\end{lstlisting}

Операцията се прилага директно върху инстанция на монада, която бива преобразувана от функцията \code{f}. Свойствата на \code{compose} се пренасят върху \code{flatMap} по следния начин:

\begin{itemize*}
  \item \emph{асоциативност} — $\forall m \in F[A], f: A \rightarrow F[B], g: B \rightarrow F[B]$ е изпълнено $flatMap(flatMap(m)(f))(g) \cong flatMap(m)(x \rightarrow flatMap(f(x))(g))$;
  \item \emph{наличие на единичен елемент} $unit$, такъв че
  \begin{itemize*}
    \item $\forall x~flatMap(unit(x))(f) = f(x)$ (\emph{лява идентичност})
    \item $\forall m \in F[A]~flatMap(m)(unit) = m$ (\emph{дясна идентичност})
  \end{itemize*}
\end{itemize*}

Нека предефинираме класа \type{Monad} чрез \code{flatMap} и дефинираме \type{compose} чрез нея. Ще дефинираме и нова операция \code{map}.

\begin{lstlisting}
trait Monad[F[_]] {
  def flatMap[A, B](m: F[A])(f: A => F[B]): F[B]
  def unit[A](a: => A): F[A]

  def compose[A, B, C](f: A => F[B], g: B => F[C]): A => F[C] =
    a => flatMap(f(a))(g)
  def map[A, B](m: F[A])(f: A => B): F[B] =
    flatMap(m)(x => unit(f(x)))
}
\end{lstlisting}

Операцията \code{flatMap} за \type{Option} трансформира един \type{Option} в друг, зависещ от стойността в първия. Нека я дефинираме в типа за опционалност:

\begin{lstlisting}
def flatMap[A, B](f: A => Option[B]): Option[B] =
  if (isEmpty) None else f(get)
\end{lstlisting}

Така може да дефинираме инстанция на \type{Option} за \type{Monad} по аналогичен начин:

\begin{lstlisting}[texcl=true]
implicit val optionMonad = new Monad[Option] {
  def flatMap[A, B](m: Option[A])(f: A => Option[B]): Option[B] =
    m flatMap f
  def unit[A](a: => A): Option[A] = Some(a)
  
  // предефиниране за оптимизация
  override def map[A, B](m: Option[A])(f: A => B): Option[B] =
    m map f
}
\end{lstlisting}

Имплементацията на \code{composedFGH} чрез \code{flatMap} е по-дълга, отколкото с \code{compose}:

\begin{lstlisting}
def composedFGH(value: Int)(implicit m: Monad[Option]): Option[Int] =
  m.flatMap(f(value)) { fResult =>
    m.flatMap(g(fResult)) { gResult =>
      h(gResult)
    }
  }
\end{lstlisting}

Ползата от \code{flatMap} се вижда когато трябва да използваме междинните резултати от функцията, което не можем да постигнем с \type{compose}. Нека например намерим сумата на резултатите от трите функции, като всяка функция извикаме с израз, съдържащ предишни резултати:

\begin{lstlisting}
def sumFGH(value: Int)(implicit m: Monad[Option]): Option[Int] =
  m.flatMap(f(value)) { fResult =>
    m.flatMap(g(fResult - value)) { gResult =>
      m.map(h(gResult * fResult)) { hResult =>
        fResult + gResult + hResult
      }
    }
  }
\end{lstlisting}

Отново ще въведем абстракция за опростяване на нашия код. Scala имплементира тази абстракция в конструкция, която нарича \code{for}:

\begin{lstlisting}
def sumFGH(value: Int): Option[Int] = for {
  fResult <- f(value)
  gResult <- g(fResult - value)
  hResult <- h(gResult * fResult)
} yield fResult + gResult + hResult
\end{lstlisting}

Конструкцията \type{for} се преобразува от компилатора на Scala до код, композиран от прилагания на \code{flatMap} и \code{map}, аналогичен с предишния. Scala обаче не знае за нашата имплементация на монади, поради което търси операциите като членове на самите обекти на монадните типове. Затова обикновено те се имплементират при дефиниция на типа. Така не можем да имаме алтернативни имплементации, но за монадите това рядко има смисъл.

Вече имаме удобна и мощна операция, която можем да използваме за всички монади, което е и смисълът от тези абстракции. Тази операция ни позволява да изразим постъпкови изчисления, но по функционален начин. Дефинирахме и операциите \code{compose} и \code{map} чрез \code{flatMap} и \code{unit}, които приехме за основни. За монадите могат да се дефинират доста други интересни операции. Нека да видим някои от тях:

\begin{lstlisting}
trait Monad[F[_]] {
  // ...
  
  def map2[A, B, C](ma: F[A], mb: F[B])(f: (A, B) => C): F[C] =
    flatMap(ma)(a => map(mb)(b => f(a, b)))
  def join[A](m: F[F[A]]): F[A] = flatMap(m)(x => x)
  def traverse[A, B](xs: List[A])(f: A => F[B]): F[List[B]] =
    xs.foldRight(unit(List[B]())) { (next, acc) =>
      map2(f(next), acc)(_ :: _)
    }
  def sequence[A](ml: List[F[A]]): F[List[A]] = traverse(ml)(m => m)
}
\end{lstlisting}

\begin{itemize*}
  \item \code{map2} ни позволява да приложим двуаргументна функция върху два монадни обекта (вместо само върху един, както е с \code{map});
  \item \code{join} опростява вложен монаден тип с едно ниво;
  \item \code{traverse} изпълнява трансформираща към монадни обекти функция върху списък от елементи и комбинира резултата в монаден обект от списък от съответните стойности;
  \item \code{sequence} ни позволява да трансформираме списък от монадни обекти в монаден обект от списък от съответните им стойности. Така успяваме да комбинираме няколко монадни обекта в един.
\end{itemize*}

По аналогичен на \type{Option} начин може да имплементираме монадна инстанция и за типовете \type{Try} и \type{Either} (\shortlabeledref{приложение}{att:fp}). Ще отбележим, че ако разрешим хвърлянето на изключения, то поради техния страничен ефект имплементацията на \type{Try} в Scala не е монад, тъй като \code{Try} конструкторът поглъща изключенията. Това води до нарушаване на дясната идентичност. Затова ще разглеждаме \type{Try} без хвърляне на изключения, а грешки ще генерираме директно чрез конструктора на \type{Failure}.

\subsection{Видове монади}

Срещат се най-различни типове монади, с доста различни едни от други ефекти.

Освен разгледаните, монади са и списъците с \code{unit} операция \code{List(a)}, която генерира списък от един елемент, и операцията \code{flatMap}, дефинирана стандартно върху списъците. Характерно е, че тя прилага подадената функция върху всеки един елемент на списъка, като резултатът е конкатенация на резултатните списъци. Списъците изразяват ефекта за множественост.

Както споменахме в \shortlabeledref{секция}{sec:immutability}, разпределеното програмиране е обвързано със странични ефекти. Съществуват монади, които енкапсулират странични ефекти. При тях те се случват, но са скрити. Потребителят няма как да забележи случващите се промените, поради което композирането на монадите остава референтно прозрачно и проследимо математически \cite[секция 3.2.4.2]{haskellwikiFP}. В следващата глава ще разгледаме монадата за асинхронни резултати \type{Future}, както и монада за асинхронни потоци.

Други интересни монади са \type{State}, съхраняващ състояние по функционален начин, I/O за функционални трансформации на вход/изход, \type{Random} за функционално генериране на псевдослучайни числа и много други.

\subsection{Монади с нули}

Нека да разгледаме монада $F$ и нека $m_{zero} \in F[A]~\forall A$. $m_{zero}$ ще наричаме нула на $F$, ако:

\begin{itemize*}
  \item $\forall f: A \rightarrow F[B]$ е изпълнено $flatMap(m_{zero})(f) = m_{zero}$;
  \item $\forall m \in F[A]$ е изпълнено $flatMap(m)(x \rightarrow m_{zero}) = m_{zero}$.
\end{itemize*}

Ако $m_{zero}$ е единствена нула и $op$ е операция, която спазва моноидните закони в множеството $F[A]$ с нула $m_{zero}$, то $F[A]$ е моноид с операция $op$. Такива са например монадата \type{Option} с операция \code{orElse} и нула \type{None} или \type{List} с операция конкатенация на списъци и нула \type{Nil}.

Пример за монада с множество нули е типа \type{Try} с обектите от \type{Failure} подтипа.

Това, което ни давата монадите с нули, е прекъсване на композицията, когато бъде срещната нула. Това е следствие от двете свойства от дефиницията на $m_{zero}$. Тогава резултатът от операцията е тази нула. Следващият код ще бъде прекъснат от първия \type{Failure}, а последващите изрази дори няма да бъдат оценени. Резултатът е първият \type{Failure}, който се явява в ролята на нула. Резултатът допълнително може да бъде композиран, без да трябва да се грижим за грешката. Последващите композиции също автоматично ще бъдат прекъснати:

\begin{lstlisting}
val res1 = for {
  a <- Success(2)
  b <- Failure(new IllegalArgumentException)
  c <- Success(a + b)
  d <- Failure(new IndexOutOfBoundsException)
} yield a + b + c + d

// res1: scala.util.Try[String] = Failure(java.lang.IllegalArgumentException)

val res2 = for {
  a <- res1
  b <- Success(4)
} yield a + b

// res2: scala.util.Try[String] = Failure(java.lang.IllegalArgumentException)
\end{lstlisting}

Едни от най-честите разклонения в логиката на програмите е за справяне с евентуални грешки, липса на стойност, празни колекции или други гранични случаи. Монадите с нули се грижат за това вместо нас и ни позволяват граничният случай автоматично да се разпространи до по-външно място, където бихме могли да направим нещо за него, вместо да го следим из цялата програма. Това може да става дори при асинхронни операции. Аналогично и операциите \code{traverse}, \code{sequence} и \code{map2} ще генерират нулева стойност, ако някои от аргументите им е нулева стойност, и ще прекъснат изчислението.

За монадите с нули можем да дефинираме следната операция:

\begin{lstlisting}
def filter[A](m: F[A])(f: A => Boolean): F[A] =
  flatMap(m) { x => if (f(x)) unit(x) else mzero }
\end{lstlisting}

\code{mzero} е някоя от нулите на монада. Бихме могли да дефинираме абстрактен метод \code{mzero} в \type{Monad}, който да я връща, или да дефинирам \code{filter} като абстрактен, като всяка имплементация спазва тази дефиниция.

Конструкцията \code{for} има поддръжка и за \code{filter}. Отново, компилаторът на Scala ще търси метода в самата инстанция на монадния тип\footnote{компилаторът на Scala всъщност ще търси метод \code{withFilter}, който е мързелива (\englishterm{lazy}) версия на \code{filter}}. Така можем да използваме \code{for} конструкции, включващи \code{if} декларации:

\begin{lstlisting}
val res = for {
  e1 <- List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
  if e1 % 2 != 0
  e2 <- List(4, 5, 6, 7, 8, 9, 10)
  if e2 < e1
} yield (e1, e2)

// res: List[(Int, Int)] = List((5,4), (7,4), (7,5), (7,6), (9,4), (9,5), (9,6), (9,7), (9,8))
\end{lstlisting}

\section{Апликативни функтори}
\label{sec:applicatives}

Апликативните функтори са друг пример за абстракция. Те имат следните операции, с прилежащите към тях правила \cite{chiusano2014FPinScala}:

\begin{lstlisting}
trait Applicative[F[_]] {
  def apply[A, B](mf: F[A => B])(ma: F[A]): F[B]
  def unit[A](a: => A): F[A]
}
\end{lstlisting}

Чрез тях могат да се дефинират познатите ни от монадите \code{map} и \code{map2}, както и разширени версии за функции на повече аргументи \code{map3}, \code{map4} и т.н. От прилагането на функции към обектите идва и самото име на апликативния функтор. Монадите всъщност са апликативни функтори, като \code{apply} може да бъде реализирам чрез \code{flatMap} и \code{unit}.

Разгледания в \shortlabeledref{секция}{sec:sum-types-either-validation} тип \type{Validation} е пример за апликативен функтор, който не е монад \cite{chiusano2014FPinScala}. Причината за това е, че искаме от него да съдържа всички възникнали грешки, вместо да спре на първата такава. Поради това може да го използваме единствено за независими операции, а не за композитни такива. Например:

\begin{lstlisting}
import Validation.validationAppl

def person(firstName: String, lastName: String, age: Int): Validation[ErrorType, Person] = {
  validationAppl.map3(
    validateName(firstName),
    validateName(lastName),
    validateAge(age)
  )(Person.apply _)
}
\end{lstlisting}

При наличие на грешки от някои от валидациите ще бъде върнат \type{Validation} обект, съдържащ всички от тях, което в случая на уеб формуляр позволява да бъдат съобщени всички грешки на потребителя.

\section{Слаба свързаност (\englishterm{weak coupling}) чрез класове на типове}

Често към някой тип обекти искаме да добавим методи, които ни интересуват само в определен контекст. Такива са например методи за сериализация/десериализация до/от различни формати. За да постигнем това в ООП е необходимо да добавим методите при дефинирането на типа. Така обаче методите биват обвързани (\englishterm{coupled}) с останалата логика на типа, което води до по-слаба кохезия. Допълнително този тип методи не винаги са известни предварително, а понякога може да имаме нужда от различни имплементации за тях, както е при сериализирането.

Нека да приложим класовете на типове и се възползваме от разделението, което предоставят. Ще разгледаме пример за сериализация до JSON формат, или по-точно до преобразуване до следните обекти:

\begin{lstlisting}
sealed trait JsonValue
case class JsonNumber(value: BigDecimal) extends JsonValue
case class JsonString(value: String) extends JsonValue
case class JsonBoolean(value: Boolean) extends JsonValue
case class JsonArray(value: Seq[JsonValue]) extends JsonValue
case class JsonObject(value: Map[String, JsonValue]) extends JsonValue
case object JsonNull extends JsonValue
\end{lstlisting}

Нека да дефинираме следния клас на типове:

\begin{lstlisting}
trait JsonSerializable[T] {
  def toJson(value: T): JsonValue
}
\end{lstlisting}

Така можем да реализираме следната функция за сериализиране до Json низ за всички типове на този клас:

\begin{lstlisting}[texcl=true]
def serializeToJson[T](value: T)(implicit js: JsonSerializable[T]): String = ???

// Поради честата употреба в Scala горната дефиниция е еквивалентна на
// def serializeToJson[T : JsonSerializable](value: T): String = ???
\end{lstlisting}

Сега нека да добавим \code{toJson} методи към всеки обект чрез механизма за имплицитно конвертиране на Scala. Те ще бъде видими само в контексти, в които се интересуваме от сериализация (за целта е нужен само \code{import}):

\begin{lstlisting}
implicit class ToJson[T](val value: T) extends AnyVal {
  def toJson(implicit js: JsonSerializable[T]) = js.toJson(value)
  def toJsonString(implicit js: JsonSerializable[T]) = serializeToJson(value)
}
\end{lstlisting}

Нека да имплементираме класа за някой тип:

\begin{lstlisting}
case class Person(firstName: String, lastName: String, age: Int, nickname: Option[String])

implicit val personJsonSerializable = new JsonSerializable[Person] {
  def toJson(person: Person) = JsonObject(Map(
    "firstName" -> JsonString(person.firstName),
    "lastName" -> JsonString(person.lastName),
    "age" -> JsonNumber(person.age),
    "nickname" -> person.nickname.map(JsonString).getOrElse(JsonNull)
  ))
}

println(Person("Ivan", "Georgiev", 25, None).toJsonString)
\end{lstlisting}

Така се възползвахме от ползите на класовете на типове за добавяне на отделна имплементация към всеки тип и за получаване на възможност за различни имплементации в зависимост от контекста. Можем например да сериализираме годините на човек или не, в зависимост дали даден потребител има достъп до тях.

Имплицитните стойности се композират автоматично:

\begin{lstlisting}
implicit def listJsonSerializable[T](implicit js: JsonSerializable[T]) = new JsonSerializable[List[T]] {
  def toJson(xs: List[T]) = JsonArray(xs map js.toJson)
}

List(
  Person("Ivan", "Georgiev", 25, None),
  Person("Georgi", "Ivanov", 19, None)
).toJson

implicit val intJsonSerializable = new JsonSerializable[Int] {
  def toJson(value: Int) = JsonNumber(value)
}
List(1, 2, 3).toJson
\end{lstlisting}

В Scala това е доста разпространен шаблон. Рамката Play, която ще разгледаме в по-късна глава, реализира JSON сериализацията именно по този начин, предоставяйки специален DSL. В стандартната библиотека също има различни примери, като \type{Ordering}, който определя наредбата на определени стойности (което ни дава възможност да я променяме в определен контекст) или \type{Numeric}, дефиниращ стандартни операции за числа.

\section{Съпоставяне по образци (\englishterm{pattern matching})}

Съпоставянето по образци (\englishterm{pattern matching}) е конструкция, която е силно характерна за функционалните езици. При него една стойност бива последователно сравняваме спрямо списък от образци, всеки свързан с програмна логика. Когато се срещне образец, по който стойността съвпада, се изпълнява неговата логика и търсенето приключва. Резултатът от съпоставянето е стойността на съответния на образеца израз. При сравнението образците могат да разбият стойността на отделни части. Функционалните езици предоставят богат набор от конструкции за изграждане на образци. Нека да разгледаме примери:

\begin{lstlisting}[texcl=true]
// неефективна имплементация, защото не е опашково-рекурсивна.
// Операцията :: разбива списъкът на глава и опашка
// Nil е празният списък
def map[A, B](xs: List[T])(f: A => B): List[B] = xs match {
  case x :: rest => f(x) :: map(rest)(f)
  case Nil => Nil
}

def transformJsonToString(value: JsonValue): String = value match {
  case JsonNumber(value) => value.toString
  case JsonString(value) => value
  case JsonBoolean(value) => value.toString
  case JsonArray(elements) =>
    "[" + elements.map(transformJsonToString).mkString(", ") + "]"
  case JsonObject(members) =>
    val membersStrings = members.map { case (key, value) =>
      s"""\"${key}\": ${transformJsonToString(value)}"""
    }
    "{" + membersStrings.mkString(", ") + "}"
  case JsonNull => "null"
}
  
def serializeToJson[T](value: T)(implicit js: JsonSerializable[T]): String = transformJsonToString(js.toJson(value))
\end{lstlisting}

Блокът с \code{case} клаузи може да се използва и отделно, както се вижда в примера със сериализиране на \type{JsonObject}. Тогава блокът се оценява до частична функция, което е тип, наследяващ \type{Function1}, но с допълнителни методи:

\begin{lstlisting}
val numberSerializer: PartialFunction[JsonValue, String] = {
  case JsonNumber(value) => value.toString
}
val stringSerializer: PartialFunction[JsonValue, String] = {
  case JsonString(value) => value
}

numberSerializer(JsonNumber(2)) // "2"
numberSerializer.isDefinedAt(JsonString("3")) // false

val combined = numberSerializer orElse stringSerializer

combined(JsonNumber(2)) // "2"
combined(JsonString("3")) // "3"
combined.isDefinedAt(JsonBoolean(true)) // false
\end{lstlisting}

Ще използваме този блок когато говорим за актьори с цел съпоставяне на дадено съобщение на списък от образци.

Чрез така наречения \englishterm{the expression problem} \cite{wadler1998TheExpressionProblem} можем да сравним съпоставянето по образци и подтиповия полиморфизъм относно добавянето на нов подтип към дадена йерархия и добавянето на операция над съществуваща йерархия от типове. Пример за това може да видим в \shortlabeledref{приложение}{att:fp}. От него следват следните изводи:

\begin{itemize*}
  \item при подтиповия полиморфизъм е лесно да се добави нов тип (дефинират се всички операции за него на едно място), но е трудно да се добави нова операция (трябва да бъде добавена към всички подтипове);
  \item при съпоставянето по образци е лесно да се добави нова операция (тя се дефинира на едно място и разглежда всички подтипове), но е трудно да се добави нов подтип (трябва случаят за него да бъде добавен към всяка една операция). Поради това най-често съпоставянето по образци се използва със \code{sealed} типове.
\end{itemize*}

Поради тези причини един език е по-изразителен когато предоставя конструкции за решаване и на двата проблема.
