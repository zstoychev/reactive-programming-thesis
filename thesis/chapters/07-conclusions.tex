\chapter{Заключение}
\label{ch:conclusions}

Проектирането на скалируеми и устойчиви приложения изисква разбиране на начина на работа на съвременните компютърни системи и на трудностите, идващи от недетерминизма на дистрибутираните системи и физическия свят. В тази дипломна работа разгледахме именно как тяхното пренебрегване води до архитектури, немоделиращи реалния свят, които не успяват да бъдат дистрибутирани, използвайки ефективно наличните им ресурси и справяйки се с големи потоци от клиенти.

Реактивните системи от своя страна приемат ограниченията на физическия свят в своя програмен модел и, ограничавайки недетерминизма и излишната синхронизация и споделеност, успяват максимално да използват наличните им ресурси. Това е изключително важно, защото значи, че за тях са необходими много по-малко физически системи, върху които да се изпълняват, справяйки се с повече клиенти едновременно. Нещо повече, тяхната архитектура позволява те да ограничават автоматично броя на системите, които използват, и да ги надигат само при необходимост. \emph{Всичко това се отразява силно положително и върху околната среда}.

Разгледахме избягването на изменяемото състояние и страничните ефекти като именно основния способ за ограничаване на недетерминизма, което ни даде възможност да изграждаме силно композитни функционални абстракции, които да скриват инцидентната сложност, но не и съществената. Това доведе и до много по-чист, преизползваем и приятен код, използвайки всички ползи от функционалното програмиране. Чрез изграждането на \englishterm{iteratee} библиотека видяхме как премахването дори на минималните налични странични ефекти многократно засилва преизползваемостта и композитността.

Използването на асинхронни съобщения под явен или неявен начин беше в основата на всички реактивни средства, които разгледахме. Оказа се, че чрез тях лесно можем да комбинираме всички средства, като всяко предоставя различни ползи и начини за контролиране на съобщенията. В главата, представяща реактивното програмиране, обобщихме, че този контрол е една от основните разлики от монолитните системи и той в голяма степен подпомага всички останали реактивни принципи. Актьорския модел е единственият разгледан инструмент, който явно подпомага всички принципи, което се дължи и на неговата инспирираност от физиката. Затова той беше използван като основния скелет на архитектурата и приложението, които бяха изградени, но при реализацията беше комбиниран с останалите инструменти по различни начини.

Самите инструменти бяха или реализирани или беше посочено как би могла да се осъществи евентуална реализация, което ни даде възможност да ги анализираме и да видим по-ясно връзките между тях, общите примитиви, които използват, поведението им в конкурентна среда, както и как могат да бъдат използвани и комбинирани.

Нуждата от реактивни системи е изключително разнообразна и най-различни предизвикателства съществуват в различните проекти. Затова разгледаното тук може да се подобри по много начини, в зависимост от нуждите. Чрез изложението в тази работа представихме основите на тези системи.

Някои идеи за бъдещи подобрения са:

\begin{itemize*}
  \item Архитектурата, която представихме, е изключително подходяща за до средно големи системи, но при по-големи клъстерът би станал твърде голям. Затова могат да се предложат различни схеми за неговото разделение на по-малки части, по типове възли, на групи от смесени типове и други. Ще отбележим, че това би станало без промяна на бизнес логиката и на самите бизнес актьори или други реактивни средства, а единствено чрез развитие на архитектурата според нуждите.
  
  \item Важен въпрос е интегрирането на големи системи, които са физически отдалечени една от друга, например в различни континенти, и постигането на консистентност между тях.
  
  \item Тук разгледахме единствено евентуална консистентност, която обаче не работи за всички сценарии. Интересна тема е използването на причинна консистентност и нейната реализация в разгледаните модели.
  
  \item Текущите имплементации на библиотеки за реактивни потоци все още не поддържат комуникация между актьорските системи, освен чрез директно осъществяване на TCP връзка. Поради това използването на потоци в реализацията беше ограничено до интерфейсните възли. Интересно е да видим работеща реализация през различни възли с обратен натиск.
  
  \item За ненатоварване на имплементацията тук използвахме Angular.js за реализация на \englishterm{dataflow} на клиентските приложения. Би могла да се направи реализация, която използва изцяло \emph{функционално реактивно програмиране} с виртуален DOM и по-добре моделира потоците и на клиентското приложение.
\end{itemize*}
